# 计算机网络

## HTTP状态码
**1xx 接收的请求正在处理**

- **100**：Continue，服务器收到了请求的初始部分，并且请客户端继续发送。比如，客户端有大文件需要上传，但是服务器是否愿意接受，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿（故是一种优化）。
（Req-Header）Expect: 100-continue   （Res-Status）100 Continue    417 Expectation Failed

- **101**：Switching Protocols，切换协议 
（Req-Res-Header）Connection: Upgrade，  Upgrade: websocket


**2xx 请求正常处理完毕**
- **204**：处理成功，但无资源可返回
- **206**：结合Content-Range指定范围的实体内容使用。客户端：我只想要其中一部分；服务端：是对资源某一部分的请求。

**3xx 重定向**
- **301**：【结合Location，指明重定向的url】代表永久重定向，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301
- **302**：【结合Location，指明重定向的url】代表临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存），这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302
- **304**：和重定向无关，资源缓存相关
> **304**
第一次请求
> + step1:  (res) 200 --> date、expires、Last-Modified、ETag
第二次请求
> + step1: 看是否需要发送请求 （查缓存，先 from memory cache 再 from disk cache）
>   + (req) cache-control：max-age=xxx 
    + 先比较当前时间和上次响应 date，如果没有超过max-age，命中本地强缓存
    + 如果没有cache-control，则取服务端 expires 的值，来对比当前时间是否过期
    + 如果都不满足，则进入协商缓存阶段（此时才需要发送请求）
>   + (req) cache-control：no-cache （直接进入协商缓存步骤）
> + step2:  协商缓存（服务端没修改资源，没必要回传）
>   + (req) If-Modified-Since: Last-Modified 该请求首部告诉服务器，如果客户端传来的最后修改时间与服务器上的一致，则直接回送 304 和 响应报头即可
>   + (req) If-None-Match: ETag-value （解决 La st-Modified 的缺陷：一个资源被修改了，但其实际内容根本没发生改变，故采用哈希标志）若服务端与客户端一致，则直接回送 304 和 响应报头即可 


**4xx 客户端请求错误码**
- **400**：一般为接口请求参数问题
- **401**：一般为认证失败
- **403**：一般为没有权限
  
**5xx 服务端请求错误码**
- **500**：
- **503**：表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。



